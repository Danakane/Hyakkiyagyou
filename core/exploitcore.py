import typing
import copy
from abc import ABCMeta, abstractmethod

from core import payloadcore


class Exploit:

    __metaclass__ = ABCMeta
    AUTHOR: str = "Danakane"

    def __init__(self) -> None:
        self.__exploitsize__: int = 0
        self.__payload__: typing.Optional[payloadcore.Payload] = None
        self.__exploitbin__: bytes = b""
        self.__compatibleploads__: typing.List[str] = []
        self.__targets__: typing.List[str] = []
        self.__target__: str = ""

    @property
    def size(self) -> int:
        return self.__exploitsize__

    @property
    def payload(self) -> payloadcore.Payload:
        return self.__payload__

    @payload.setter
    def payload(self, payload: payloadcore.Payload) -> None:
        self.__payload__ = payload

    @property
    def payloadbin(self) -> bytes:
        return self.__payload__.binary()

    @property
    def comploads(self) -> typing.List[str]:
        return self.__compatibleploads__

    @property
    def target(self) -> str:
        return self.__target__

    @target.setter
    def target(self, target: str) -> None:
        self.__target__ = target

    @property
    def targets(self) -> typing.List[str]:
        return self.__targets__

    def clone(self) -> "Exploit":
        return copy.deepcopy(self)

    def binary(self) -> bytes:
        return self.__exploitbin__

    def customize(self, compatibleploads: typing.List[str] = None, targets: typing.List[str] = None) -> None:
        self.__exploitsize__ = 0
        self.__payload__ = None
        self.__exploitbin__ = b""
        if not compatibleploads:
            compatibleploads: typing.List[str] = []
        self.__compatibleploads__ = compatibleploads
        if not targets:
            targets: typing.List[str] = []
        self.__targets__ = targets

    def generate(self, payload: payloadcore.Payload, target: str = "") -> "Exploit":
        exploit = copy.deepcopy(self)
        exploit.payload = payload
        targets: typing.List[str] = [t for t in self.__targets__ if t.lower() == target.lower()]
        if not targets:
            targets = self.__targets__
        exploit.target = targets[0]
        return exploit

    @abstractmethod
    def run(self, rsockaddr: typing.Tuple[typing.Any, ...]) -> typing.Any:
        # rsockaddr is a tuple obtained
        # from netutils.getsockaddr()
        # and that fit tcp socket bind()/connect()
        # regardless of the socket type
        pass
