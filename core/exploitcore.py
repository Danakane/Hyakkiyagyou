import typing
import copy
import random
import string
from abc import ABCMeta, abstractmethod

from pytoolcore import exception
from core import payloadcore


class Exploit:

    __metaclass__ = ABCMeta

    def __init__(self, author: str, ref: str = "", compatibleploads: typing.List[str] = None,
                 targets: typing.List[str] = None)->None:
        if not ref:
            ref = "exploit_" + "".join(random.choices(string.ascii_lowercase + string.digits, k=16))
        self.__ref__ = ref
        self.__author__ = author
        self.__exploitsize__: int = 0
        self.__payload__: payloadcore.Payload = None
        self.__exploitbin__: bytes = b""
        if not compatibleploads:
            compatibleploads: typing.List[str] = []
        self.__compatibleploads__: typing.List[str] = compatibleploads
        if not targets:
            targets: typing.List[str] = []
        self.__targets__: typing.List[str] = targets
        self.__target__: str = ""

    @property
    def author(self)->str:
        return self.__author__

    @property
    def ref(self)->str:
        return self.__ref__

    @property
    def size(self)->int:
        return self.__exploitsize__

    @property
    def payload(self)-> payloadcore.Payload:
        return self.__payload__

    @payload.setter
    def payload(self, payload: payloadcore.Payload)->None:
        if payload:
            if payload.ref in self.__compatibleploads__:
                self.__payload__ = payload
            else:
                raise exception.ErrorException("Unsupported type of payload")

    @property
    def payloadbin(self)->bytes:
        return self.__payload__.binary()

    @property
    def comploads(self)->typing.List[str]:
        return self.__compatibleploads__

    @property
    def target(self)->str:
        return self.__target__

    @target.setter
    def target(self, target: str)->None:
        self.__target__ = target

    @property
    def targets(self)->typing.List[str]:
        return self.__targets__

    def clone(self):
        return copy.deepcopy(self)

    def generate(self, payload: payloadcore.Payload, target: str = ""):
        exploit = copy.deepcopy(self)
        exploit.payload = payload
        targets: typing.List[str] = [t for t in self.__targets__ if t.lower() == target.lower()]
        if not targets:
            targets = self.__targets__
        exploit.target = targets[0]
        return exploit

    @abstractmethod
    def run(self, rsockaddr: typing.Tuple[typing.Any, ...])->typing.Any:
        # rsockaddr is a tuple obtained
        # from netutils.getsockaddr()
        # and that fit tcp socket bind()/connect()
        # regardless of the socket type
        pass

    def binary(self)->bytes:
        return self.__exploitbin__
